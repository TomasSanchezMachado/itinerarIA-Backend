"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SerializationContext = void 0;
const Utils_1 = require("../utils/Utils");
const wrap_1 = require("../entity/wrap");
/**
 * Helper that allows to keep track of where we are currently at when serializing complex entity graph with cycles.
 * Before we process a property, we call `visit` that checks if it is not a cycle path (but allows to pass cycles that
 * are defined in populate hint). If not, we proceed and call `leave` afterwards.
 */
class SerializationContext {
    constructor(populate = []) {
        this.populate = populate;
        this.path = [];
        this.visited = new Set();
        this.entities = new Set();
    }
    visit(entityName, prop) {
        if (!this.path.find(([cls, item]) => entityName === cls && prop === item)) {
            this.path.push([entityName, prop]);
            return false;
        }
        // check if the path is explicitly populated
        if (!this.isMarkedAsPopulated(prop)) {
            return true;
        }
        this.path.push([entityName, prop]);
        return false;
    }
    leave(entityName, prop) {
        const last = this.path.pop();
        /* istanbul ignore next */
        if (!last || last[0] !== entityName || last[1] !== prop) {
            throw new Error(`Trying to leave wrong property: ${entityName}.${prop} instead of ${last?.join('.')}`);
        }
    }
    close() {
        this.entities.forEach(entity => {
            delete (0, wrap_1.helper)(entity).__serializationContext.root;
        });
    }
    /**
     * When initializing new context, we need to propagate it to the whole entity graph recursively.
     */
    static propagate(root, entity, isVisible) {
        root.register(entity);
        const meta = (0, wrap_1.helper)(entity).__meta;
        const items = [];
        Object.keys(entity)
            .filter(key => isVisible(meta, key))
            .forEach(key => {
            if (Utils_1.Utils.isEntity(entity[key], true)) {
                items.push(entity[key]);
            }
            else if (Utils_1.Utils.isCollection(entity[key])) {
                items.push(...entity[key].getItems(false));
            }
        });
        items
            .filter(item => !item.__helper.__serializationContext.root)
            .forEach(item => this.propagate(root, item, isVisible));
    }
    isMarkedAsPopulated(prop) {
        let populate = this.populate;
        for (const segment of this.path) {
            if (!populate) {
                return false;
            }
            const exists = populate.find(p => p.field === segment[1]);
            if (exists) {
                populate = exists.children;
            }
        }
        return !!populate?.find(p => p.field === prop);
    }
    register(entity) {
        (0, wrap_1.helper)(entity).__serializationContext.root = this;
        this.entities.add(entity);
    }
}
exports.SerializationContext = SerializationContext;
