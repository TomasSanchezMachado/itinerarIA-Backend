/// <reference types="node" />
import { inspect } from 'util';
import type { Platform } from '../platforms';
import type { Constructor, EntityMetadata, EntityProperty } from '../typings';
export interface TransformContext {
    fromQuery?: boolean;
    key?: string;
    mode?: 'hydration' | 'query' | 'query-data' | 'discovery' | 'serialization';
}
export declare abstract class Type<JSType = string, DBType = JSType> {
    private static readonly types;
    platform?: Platform;
    meta?: EntityMetadata;
    prop?: EntityProperty;
    /**
     * Converts a value from its JS representation to its database representation of this type.
     */
    convertToDatabaseValue(value: JSType | DBType, platform: Platform, context?: TransformContext | boolean): DBType;
    /**
     * Converts a value from its database representation to its JS representation of this type.
     */
    convertToJSValue(value: JSType | DBType, platform: Platform): JSType;
    /**
     * Converts a value from its JS representation to its database representation of this type.
     */
    convertToDatabaseValueSQL?(key: string, platform: Platform): string;
    /**
     * Modifies the SQL expression (identifier, parameter) to convert to a JS value.
     */
    convertToJSValueSQL?(key: string, platform: Platform): string;
    /**
     * How should the raw database values be compared? Used in `EntityComparator`.
     * Possible values: string | number | boolean | date | any | buffer | array
     */
    compareAsType(): string;
    /**
     * When a value is hydrated, we convert it back to the database value to ensure comparability,
     * as often the raw database response is not the same as the `convertToDatabaseValue` result.
     * This allows to disable the additional conversion in case you know it is not needed.
     */
    ensureComparable<T extends object>(meta: EntityMetadata<T>, prop: EntityProperty<T>): boolean;
    /**
     * Converts a value from its JS representation to its serialized JSON form of this type.
     * By default uses the runtime value.
     */
    toJSON(value: JSType, platform: Platform): JSType | DBType;
    /**
     * Gets the SQL declaration snippet for a field of this type.
     */
    getColumnType(prop: EntityProperty, platform: Platform): string;
    static getType<JSType, DBType = JSType>(cls: Constructor<Type<JSType, DBType>>): Type<JSType, DBType>;
    /**
     * Checks whether the argument is instance of `Type`.
     */
    static isMappedType(data: any): data is Type<any>;
    /**
     * Checks whether the argument is instance of custom `Type` class provided by the user.
     */
    static isCustomType(data: any): data is Type<any>;
    [inspect.custom](depth: number): string;
}
