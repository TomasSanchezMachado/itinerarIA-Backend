/// <reference types="node" />
import { inspect } from 'util';
import type { EntityManager } from '../EntityManager';
import type { ConnectionType, Dictionary, EntityData, EntityDictionary, EntityMetadata, IHydrator, Populate, PopulateOptions, Primary, AutoPath, Loaded } from '../typings';
import { Reference, type IdentifiedReference } from './Reference';
import { type AssignOptions } from './EntityAssigner';
import type { EntityLoaderOptions } from './EntityLoader';
import type { LockMode } from '../enums';
import type { EntityIdentifier } from './EntityIdentifier';
import type { SerializationContext } from '../serialization/SerializationContext';
export declare class WrappedEntity<T extends object, PK extends keyof T> {
    private readonly entity;
    private readonly hydrator;
    private readonly pkGetter?;
    private readonly pkSerializer?;
    private readonly pkGetterConverted?;
    __initialized: boolean;
    __touched: boolean;
    __populated?: boolean;
    __lazyInitialized?: boolean;
    __managed?: boolean;
    __onLoadFired?: boolean;
    __schema?: string;
    __em?: EntityManager;
    __serializationContext: {
        root?: SerializationContext<T>;
        populate?: PopulateOptions<T>[];
    };
    __loadedProperties: Set<string>;
    __data: Dictionary;
    __processing: boolean;
    /** stores last known primary key, as its current state might be broken due to propagation/orphan removal, but we need to know the PK to be able t remove the entity */
    __pk?: Primary<T>;
    /** holds the reference wrapper instance (if created), so we can maintain the identity on reference wrappers too */
    __reference?: Reference<T>;
    /** holds last entity data snapshot, so we can compute changes when persisting managed entities */
    __originalEntityData?: EntityData<T>;
    /** holds wrapped primary key, so we can compute change set without eager commit */
    __identifier?: EntityIdentifier;
    constructor(entity: T, hydrator: IHydrator, pkGetter?: ((e: T) => Primary<T>) | undefined, pkSerializer?: ((e: T) => string) | undefined, pkGetterConverted?: ((e: T) => Primary<T>) | undefined);
    isInitialized(): boolean;
    isTouched(): boolean;
    populated(populated?: boolean): void;
    toReference(): IdentifiedReference<T, PK>;
    toObject(ignoreFields?: string[]): EntityData<T>;
    toPOJO(): EntityData<T>;
    toJSON(...args: any[]): EntityDictionary<T>;
    assign(data: EntityData<T>, options?: AssignOptions): T;
    init<P extends Populate<T> = Populate<T>>(populated?: boolean, populate?: P, lockMode?: LockMode, connectionType?: ConnectionType): Promise<T>;
    populate<Hint extends string = never>(populate: AutoPath<T, Hint>[] | boolean, options?: EntityLoaderOptions<T, Hint>): Promise<Loaded<T, Hint>>;
    hasPrimaryKey(): boolean;
    getPrimaryKey(convertCustomTypes?: boolean): Primary<T> | null;
    getPrimaryKeys(convertCustomTypes?: boolean): Primary<T>[] | null;
    getSchema(): string | undefined;
    setSchema(schema?: string): void;
    setPrimaryKey(id: Primary<T> | null): void;
    getSerializedPrimaryKey(): string;
    get __meta(): EntityMetadata<T>;
    get __platform(): import("..").Platform;
    get __primaryKeys(): Primary<T>[];
    [inspect.custom](): string;
}
