"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObjectHydrator = void 0;
const Hydrator_1 = require("./Hydrator");
const Collection_1 = require("../entity/Collection");
const Reference_1 = require("../entity/Reference");
const Utils_1 = require("../utils/Utils");
const enums_1 = require("../enums");
class ObjectHydrator extends Hydrator_1.Hydrator {
    constructor() {
        super(...arguments);
        this.hydrators = {
            full: new Map(),
            reference: new Map(),
        };
        this.tmpIndex = 0;
    }
    /**
     * @inheritDoc
     */
    hydrate(entity, meta, data, factory, type, newEntity = false, convertCustomTypes = false, schema) {
        const hydrate = this.getEntityHydrator(meta, type);
        const running = this.running;
        // the running state is used to consider propagation as hydration, saving the values directly to the entity data,
        // but we don't want that for new entities, their propagation should result in entity updates when flushing
        this.running = !newEntity;
        Utils_1.Utils.callCompiledFunction(hydrate, entity, data, factory, newEntity, convertCustomTypes, schema);
        this.running = running;
    }
    /**
     * @inheritDoc
     */
    hydrateReference(entity, meta, data, factory, convertCustomTypes = false, schema) {
        const hydrate = this.getEntityHydrator(meta, 'reference');
        const running = this.running;
        this.running = true;
        Utils_1.Utils.callCompiledFunction(hydrate, entity, data, factory, false, convertCustomTypes, schema);
        this.running = running;
    }
    /**
     * @internal Highly performance-sensitive method.
     */
    getEntityHydrator(meta, type) {
        const exists = this.hydrators[type].get(meta.className);
        if (exists) {
            return exists;
        }
        const lines = [];
        const context = new Map();
        const props = this.getProperties(meta, type);
        context.set('isPrimaryKey', Utils_1.Utils.isPrimaryKey);
        context.set('Collection', Collection_1.Collection);
        context.set('Reference', Reference_1.Reference);
        const preCondition = (dataKey) => {
            /* istanbul ignore next */
            const path = dataKey.match(/\[[^\]]+]|\.\w+/g) ?? [];
            path.pop();
            if (path.length === 0) {
                return '';
            }
            let ret = '';
            let prev = '';
            for (const p of path) {
                const key = prev ? prev + p : p;
                ret += `data${key} && `;
                prev = key;
            }
            return ret;
        };
        const hydrateScalar = (prop, object, path, dataKey) => {
            const entityKey = path.map(k => this.wrap(k)).join('');
            const preCond = preCondition(dataKey);
            const convertorKey = path.filter(k => !k.match(/\[idx_\d+]/)).map(k => this.safeKey(k)).join('_');
            const ret = [];
            const nullVal = this.config.get('forceUndefined') ? 'undefined' : 'null';
            if (prop.type.toLowerCase() === 'date') {
                ret.push(`  if (${preCond}data${dataKey}) entity${entityKey} = new Date(data${dataKey});`, `  else if (${preCond}data${dataKey} === null) entity${entityKey} = ${nullVal};`);
            }
            else if (prop.customType) {
                context.set(`convertToJSValue_${convertorKey}`, (val) => prop.customType.convertToJSValue(val, this.platform));
                context.set(`convertToDatabaseValue_${convertorKey}`, (val) => prop.customType.convertToDatabaseValue(val, this.platform, { mode: 'hydration' }));
                ret.push(`  if (${preCond}typeof data${dataKey} !== 'undefined') {`, `    if (convertCustomTypes) {`, `      const value = convertToJSValue_${convertorKey}(data${dataKey});`);
                if (prop.customType.ensureComparable(meta, prop)) {
                    ret.push(`      data${dataKey} = convertToDatabaseValue_${convertorKey}(value);`);
                }
                ret.push(`      entity${entityKey} = value;`, `    } else {`, `      entity${entityKey} = data${dataKey};`, `    }`, `  }`);
            }
            else if (prop.type.toLowerCase() === 'boolean') {
                ret.push(`  if (${preCond}typeof data${dataKey} !== 'undefined') entity${entityKey} = data${dataKey} === null ? ${nullVal} : !!data${dataKey};`);
            }
            else {
                ret.push(`  if (${preCond}typeof data${dataKey} !== 'undefined') entity${entityKey} = data${dataKey};`);
            }
            return ret;
        };
        const hydrateToOne = (prop, dataKey, entityKey) => {
            const ret = [];
            const nullVal = this.config.get('forceUndefined') ? 'undefined' : 'null';
            ret.push(`  if (data${dataKey} === null) {\n    entity${entityKey} = ${nullVal};`);
            ret.push(`  } else if (typeof data${dataKey} !== 'undefined') {`);
            ret.push(`    if (isPrimaryKey(data${dataKey}, true)) {`);
            if (prop.wrappedReference) {
                ret.push(`      entity${entityKey} = Reference.create(factory.createReference('${prop.type}', data${dataKey}, { merge: true, convertCustomTypes, schema }));`);
            }
            else {
                ret.push(`      entity${entityKey} = factory.createReference('${prop.type}', data${dataKey}, { merge: true, convertCustomTypes, schema });`);
            }
            ret.push(`    } else if (data${dataKey} && typeof data${dataKey} === 'object') {`);
            if (prop.wrappedReference) {
                ret.push(`      entity${entityKey} = Reference.create(factory.create('${prop.type}', data${dataKey}, { initialized: true, merge: true, newEntity, convertCustomTypes, schema }));`);
            }
            else {
                ret.push(`      entity${entityKey} = factory.create('${prop.type}', data${dataKey}, { initialized: true, merge: true, newEntity, convertCustomTypes, schema });`);
            }
            ret.push(`    }`);
            ret.push(`  }`);
            if (prop.reference === enums_1.ReferenceType.ONE_TO_ONE) {
                const meta2 = this.metadata.get(prop.type);
                const prop2 = meta2.properties[prop.inversedBy || prop.mappedBy];
                if (prop2 && !prop2.mapToPk) {
                    ret.push(`  if (data${dataKey} && entity${entityKey} && !entity${entityKey}.${this.safeKey(prop2.name)}) {`);
                    ret.push(`    entity${entityKey}.${prop.wrappedReference ? 'unwrap().' : ''}${this.safeKey(prop2.name)} = ${prop2.wrappedReference ? 'Reference.create(entity)' : 'entity'};`);
                    ret.push(`  }`);
                }
            }
            if (prop.customType?.ensureComparable(meta, prop)) {
                context.set(`convertToDatabaseValue_${this.safeKey(prop.name)}`, (val) => prop.customType.convertToDatabaseValue(val, this.platform, { mode: 'hydration' }));
                ret.push(`  if (data${dataKey} != null && convertCustomTypes) {`);
                ret.push(`    data${dataKey} = convertToDatabaseValue_${this.safeKey(prop.name)}(entity${entityKey}.__helper.getPrimaryKey());`);
                ret.push(`  }`);
            }
            return ret;
        };
        const hydrateToMany = (prop, dataKey, entityKey) => {
            const ret = [];
            ret.push(...this.createCollectionItemMapper(prop));
            ret.push(`  if (data${dataKey} && !Array.isArray(data${dataKey}) && typeof data${dataKey} === 'object') {`);
            ret.push(`    data${dataKey} = [data${dataKey}];`);
            ret.push(`  }`);
            ret.push(`  if (Array.isArray(data${dataKey})) {`);
            ret.push(`    const items = data${dataKey}.map(value => createCollectionItem_${this.safeKey(prop.name)}(value, entity));`);
            ret.push(`    const coll = Collection.create(entity, '${prop.name}', items, newEntity);`);
            ret.push(`    if (newEntity) {`);
            ret.push(`      coll.setDirty();`);
            ret.push(`    } else {`);
            ret.push(`      coll.takeSnapshot(true);`);
            ret.push(`    }`);
            ret.push(`  } else if (!entity${entityKey} && data${dataKey} instanceof Collection) {`);
            ret.push(`    entity${entityKey} = data${dataKey};`);
            ret.push(`  } else if (!entity${entityKey}) {`);
            const items = this.platform.usesPivotTable() || !prop.owner ? 'undefined' : '[]';
            ret.push(`    const coll = Collection.create(entity, '${prop.name}', ${items}, !!data${dataKey} || newEntity);`);
            ret.push(`    coll.setDirty(false);`);
            ret.push(`  }`);
            return ret;
        };
        const registerEmbeddedPrototype = (prop, path) => {
            const convertorKey = path.filter(k => !k.match(/\[idx_\d+]/)).map(k => this.safeKey(k)).join('_');
            if (prop.targetMeta?.polymorphs) {
                prop.targetMeta.polymorphs.forEach(meta => {
                    context.set(`prototype_${convertorKey}_${meta.className}`, meta.prototype);
                });
            }
            else {
                context.set(`prototype_${convertorKey}`, prop.embeddable.prototype);
            }
        };
        const parseObjectEmbeddable = (prop, dataKey, ret) => {
            if (!this.platform.convertsJsonAutomatically() && (prop.object || prop.array)) {
                context.set('parseJsonSafe', Utils_1.parseJsonSafe);
                ret.push(`  if (typeof data${dataKey} === 'string') {`, `    data${dataKey} = parseJsonSafe(data${dataKey});`, `  }`);
            }
        };
        const createCond = (prop, dataKey, cond) => {
            const conds = [];
            if (prop.object) {
                conds.push(`data${dataKey} ${cond ?? '!= null'}`);
            }
            else {
                const notNull = cond ?? (prop.nullable ? '!= null' : '!== undefined');
                meta.props
                    .filter(p => p.embedded?.[0] === prop.name)
                    .forEach(p => {
                    if (p.reference === enums_1.ReferenceType.EMBEDDED && !p.object && !p.array) {
                        conds.push(...createCond(p, dataKey + this.wrap(p.embedded[1]), cond));
                        return;
                    }
                    conds.push(`data${this.wrap(p.name)} ${notNull}`);
                });
            }
            return conds;
        };
        const hydrateEmbedded = (prop, path, dataKey) => {
            const entityKey = path.map(k => this.wrap(k)).join('');
            const ret = [];
            registerEmbeddedPrototype(prop, path);
            parseObjectEmbeddable(prop, dataKey, ret);
            ret.push(`  if (${createCond(prop, dataKey).join(' || ')}) {`);
            if (prop.targetMeta?.polymorphs) {
                prop.targetMeta.polymorphs.forEach(meta => {
                    const childProp = prop.embeddedProps[prop.targetMeta.discriminatorColumn];
                    const childDataKey = prop.object ? dataKey + this.wrap(childProp.embedded[1]) : this.wrap(childProp.name);
                    // weak comparison as we can have numbers that might have been converted to strings due to being object keys
                    ret.push(`    if (data${childDataKey} == '${meta.discriminatorValue}' && entity${entityKey} == null) {`);
                    ret.push(`      entity${entityKey} = factory.createEmbeddable('${meta.className}', data${prop.object ? dataKey : ''}, { newEntity, convertCustomTypes });`);
                    ret.push(`    }`);
                });
            }
            else {
                ret.push(`    if (entity${entityKey} == null) {`);
                ret.push(`      entity${entityKey} = factory.createEmbeddable('${prop.targetMeta.className}', data${prop.object ? dataKey : ''}, { newEntity, convertCustomTypes });`);
                ret.push(`    }`);
            }
            meta.props
                .filter(p => p.embedded?.[0] === prop.name)
                .forEach(childProp => {
                const childDataKey = prop.object ? dataKey + this.wrap(childProp.embedded[1]) : this.wrap(childProp.name);
                // eslint-disable-next-line @typescript-eslint/no-use-before-define
                ret.push(...hydrateProperty(childProp, prop.object, [...path, childProp.embedded[1]], childDataKey).map(l => '  ' + l));
            });
            /* istanbul ignore next */
            const nullVal = this.config.get('forceUndefined') ? 'undefined' : 'null';
            if (prop.object) {
                ret.push(`  } else if (data${dataKey} === null) {`);
            }
            else {
                ret.push(`  } else if (${createCond(prop, dataKey, '=== null').join(' && ')}) {`);
            }
            ret.push(`    entity${entityKey} = ${nullVal};`);
            ret.push(`  }`);
            return ret;
        };
        const hydrateEmbeddedArray = (prop, path, dataKey) => {
            const entityKey = path.map(k => this.wrap(k)).join('');
            const ret = [];
            const idx = this.tmpIndex++;
            registerEmbeddedPrototype(prop, path);
            parseObjectEmbeddable(prop, dataKey, ret);
            ret.push(`  if (Array.isArray(data${dataKey})) {`);
            ret.push(`    entity${entityKey} = [];`);
            ret.push(`    data${dataKey}.forEach((_, idx_${idx}) => {`);
            ret.push(...hydrateEmbedded(prop, [...path, `[idx_${idx}]`], `${dataKey}[idx_${idx}]`).map(l => '    ' + l));
            ret.push(`    });`);
            ret.push(`  }`);
            return ret;
        };
        const hydrateProperty = (prop, object = prop.object, path = [prop.name], dataKey) => {
            const entityKey = path.map(k => this.wrap(k)).join('');
            dataKey = dataKey ?? (object ? entityKey : this.wrap(prop.name));
            const ret = [];
            if ([enums_1.ReferenceType.MANY_TO_ONE, enums_1.ReferenceType.ONE_TO_ONE].includes(prop.reference) && !prop.mapToPk) {
                ret.push(...hydrateToOne(prop, dataKey, entityKey));
            }
            else if (prop.reference === enums_1.ReferenceType.ONE_TO_MANY || prop.reference === enums_1.ReferenceType.MANY_TO_MANY) {
                ret.push(...hydrateToMany(prop, dataKey, entityKey));
            }
            else if (prop.reference === enums_1.ReferenceType.EMBEDDED) {
                if (prop.array) {
                    ret.push(...hydrateEmbeddedArray(prop, path, dataKey));
                }
                else {
                    ret.push(...hydrateEmbedded(prop, path, dataKey));
                    if (!prop.object) {
                        ret.push(...hydrateEmbedded({ ...prop, object: true }, path, dataKey));
                    }
                }
            }
            else { // ReferenceType.SCALAR
                ret.push(...hydrateScalar(prop, object, path, dataKey));
            }
            if (this.config.get('forceUndefined')) {
                ret.push(`  if (data${dataKey} === null) entity${entityKey} = undefined;`);
            }
            return ret;
        };
        for (const prop of props) {
            lines.push(...hydrateProperty(prop));
        }
        const code = `// compiled hydrator for entity ${meta.className} (${type})\n`
            + `return function(entity, data, factory, newEntity, convertCustomTypes, schema) {\n`
            + `${lines.join('\n')}\n}`;
        const hydrator = Utils_1.Utils.createFunction(context, code);
        this.hydrators[type].set(meta.className, hydrator);
        return hydrator;
    }
    createCollectionItemMapper(prop) {
        const meta = this.metadata.get(prop.type);
        const lines = [];
        lines.push(`  const createCollectionItem_${this.safeKey(prop.name)} = (value, entity) => {`);
        const prop2 = prop.targetMeta?.properties[prop.mappedBy];
        if (prop2?.primary) {
            lines.push(`    if (typeof value === 'object' && value?.['${prop2.name}'] == null) {`);
            lines.push(`      value = { ...value, ['${prop2.name}']: Reference.wrapReference(entity, { wrappedReference: ${prop2.wrappedReference} }) };`);
            lines.push(`    }`);
        }
        lines.push(`    if (isPrimaryKey(value, ${meta.compositePK})) return factory.createReference('${prop.type}', value, { convertCustomTypes, schema, merge: true });`);
        lines.push(`    if (value && value.__entity) return value;`);
        if (prop2 && !prop2.primary) {
            lines.push(`    if (typeof value === 'object' && value?.['${prop2.name}'] == null) {`);
            lines.push(`      value = { ...value, ['${prop2.name}']: Reference.wrapReference(entity, { wrappedReference: ${prop2.wrappedReference} }) };`);
            lines.push(`    }`);
        }
        lines.push(`    return factory.create('${prop.type}', value, { newEntity, convertCustomTypes, schema, merge: true });`);
        lines.push(`  }`);
        return lines;
    }
    wrap(key) {
        if (key.match(/^\[.*]$/)) {
            return key;
        }
        return key.match(/^\w+$/) ? `.${key}` : `['${key}']`;
    }
    safeKey(key) {
        return key.replace(/[^\w]/g, '_');
    }
}
exports.ObjectHydrator = ObjectHydrator;
