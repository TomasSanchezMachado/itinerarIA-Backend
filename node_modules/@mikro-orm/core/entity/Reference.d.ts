/// <reference types="node" />
import { inspect } from 'util';
import type { Cast, ConnectionType, Dictionary, EntityClass, EntityProperty, IsUnknown, LoadedReference, Populate, Primary, PrimaryProperty, Ref } from '../typings';
import type { LockMode } from '../enums';
/** @deprecated use `Ref` instead, `IdentifiedReference` type will be removed in v6 */
export type IdentifiedReference<T, PK extends keyof T | unknown = PrimaryProperty<T>> = true extends IsUnknown<PK> ? Reference<T> : ({
    [K in Cast<PK, keyof T>]: T[K];
} & Reference<T>);
export declare class Reference<T> {
    private entity;
    constructor(entity: T);
    static create<T extends object, PK extends keyof T | unknown = PrimaryProperty<T>>(entity: T | IdentifiedReference<T, PK>): IdentifiedReference<T, PK>;
    static createFromPK<T extends object, PK extends keyof T | unknown = PrimaryProperty<T>>(entityType: EntityClass<T>, pk: Primary<T>, options?: {
        schema?: string;
    }): IdentifiedReference<T, PK>;
    static createNakedFromPK<T extends object, PK extends keyof T | unknown = PrimaryProperty<T>>(entityType: EntityClass<T>, pk: Primary<T>, options?: {
        schema?: string;
    }): T;
    /**
     * Checks whether the argument is instance of `Reference` wrapper.
     */
    static isReference<T extends object>(data: any): data is Reference<T>;
    /**
     * Wraps the entity in a `Reference` wrapper if the property is defined as `wrappedReference`.
     */
    static wrapReference<T extends object>(entity: T | Reference<T>, prop: EntityProperty<T>): Reference<T> | T;
    /**
     * Returns wrapped entity.
     */
    static unwrapReference<T extends object>(ref: T | Reference<T>): T;
    /**
     * Ensures the underlying entity is loaded first (without reloading it if it already is loaded).
     * Returns the entity.
     */
    load<K extends keyof T = never, P extends string = never>(options?: LoadReferenceOptions<T, P>): Promise<T>;
    /**
     * Ensures the underlying entity is loaded first (without reloading it if it already is loaded).
     * Returns the requested property instead of the whole entity.
     */
    load<K extends keyof T>(prop: K): Promise<T[K]>;
    set(entity: T | IdentifiedReference<T>): void;
    unwrap(): T;
    getEntity(): T;
    getProperty<K extends keyof T>(prop: K): T[K];
    isInitialized(): boolean;
    populated(populated?: boolean): void;
    toJSON(...args: any[]): Dictionary;
    [inspect.custom](depth: number): string;
}
export interface LoadReferenceOptions<T, P extends string = never> {
    populate?: Populate<T, P>;
    lockMode?: Exclude<LockMode, LockMode.OPTIMISTIC>;
    connectionType?: ConnectionType;
}
/**
 * shortcut for `wrap(entity).toReference()`
 */
export declare function ref<T extends object, PK extends keyof T | unknown = PrimaryProperty<T>>(entity: T | Ref<T, any>): Ref<T, PK> & LoadedReference<T>;
/**
 * shortcut for `Reference.createFromPK(entityType, pk)`
 */
export declare function ref<T extends object, PK extends keyof T | unknown = PrimaryProperty<T>, PKV extends Primary<T> = Primary<T>>(entityType: EntityClass<T>, pk?: T | PKV): Ref<T, PK>;
/**
 * shortcut for `Reference.createNakedFromPK(entityType, pk)`
 */
export declare function rel<T extends object, PK extends Primary<T>>(entityType: EntityClass<T>, pk: T | PK): T;
export { Reference as Ref };
