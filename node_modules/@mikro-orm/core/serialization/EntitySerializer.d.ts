import type { AutoPath, EntityDTO, Loaded } from '../typings';
export declare class EntitySerializer {
    static serialize<T extends object, P extends string = never>(entity: T, options?: SerializeOptions<T, P>): EntityDTO<Loaded<T, P>>;
    private static propertyName;
    private static processProperty;
    private static extractChildOptions;
    private static processEntity;
    private static processCollection;
}
export interface SerializeOptions<T extends object, P extends string = never> {
    /** Specify which relation should be serialized as populated and which as a FK. */
    populate?: AutoPath<T, P>[] | boolean;
    /** Specify which properties should be omitted. */
    exclude?: AutoPath<T, P>[];
    /** Enforce unpopulated references to be returned as objects, e.g. `{ author: { id: 1 } }` instead of `{ author: 1 }`. */
    forceObject?: boolean;
    /** Ignore custom property serializers. */
    ignoreSerializers?: boolean;
    /** Skip properties with `null` value. */
    skipNull?: boolean;
}
/**
 * Converts entity instance to POJO, converting the `Collection`s to arrays and unwrapping the `Reference` wrapper, while respecting the serialization options.
 */
export declare function serialize<T extends object, P extends string = never>(entity: T, options?: SerializeOptions<T, P>): EntityDTO<Loaded<T, P>>;
/**
 * Converts entity instance to POJO, converting the `Collection`s to arrays and unwrapping the `Reference` wrapper, while respecting the serialization options.
 */
export declare function serialize<T extends object, P extends string = never>(entities: T[], options?: SerializeOptions<T, P>): EntityDTO<Loaded<T, P>>[];
